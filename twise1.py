# -*- coding: utf-8 -*-
"""twise1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aPcmhA8XYblyynJqzuceaMpvlrjUsHE4
"""

import streamlit as st
import zipfile
import os
import shutil
import tempfile
from PIL import Image
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import accuracy_score
import numpy as np

st.set_page_config(page_title="Image Classifier", layout="wide")

# Global variables
best_model = None
class_names = []

# Function to unzip and extract
def extract_zip(zip_path):
    temp_dir = tempfile.mkdtemp()
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_ref.extractall(temp_dir)
    return temp_dir

# Function to create model
def create_model(name, input_shape, num_classes):
    base_model = None
    if name == "Facebook":
        base_model = tf.keras.applications.ResNet50(weights='imagenet', include_top=False, input_shape=input_shape)
    elif name == "Google":
        base_model = tf.keras.applications.MobileNetV2(weights='imagenet', include_top=False, input_shape=input_shape)
    elif name == "Microsoft":
        base_model = tf.keras.applications.EfficientNetB0(weights='imagenet', include_top=False, input_shape=input_shape)

    model = tf.keras.Sequential([
        base_model,
        tf.keras.layers.GlobalAveragePooling2D(),
        tf.keras.layers.Dense(128, activation='relu'),
        tf.keras.layers.Dense(num_classes, activation='softmax')
    ])
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# Training function
def train_model(model_name, train_dir, val_dir, input_shape=(224, 224, 3)):
    datagen = ImageDataGenerator(rescale=1./255)

    train_gen = datagen.flow_from_directory(train_dir, target_size=input_shape[:2], batch_size=32, class_mode='categorical')
    val_gen = datagen.flow_from_directory(val_dir, target_size=input_shape[:2], batch_size=32, class_mode='categorical')

    model = create_model(model_name, input_shape, num_classes=len(train_gen.class_indices))
    model.fit(train_gen, epochs=3, validation_data=val_gen, verbose=0)

    val_gen.reset()
    pred_probs = model.predict(val_gen)
    preds = np.argmax(pred_probs, axis=1)
    labels = val_gen.classes
    acc = accuracy_score(labels, preds)

    return model, acc, list(train_gen.class_indices.keys())

# Streamlit interface
st.title("🧠 Application de Classification d’Images")

# Sidebar Navigation
page = st.sidebar.selectbox("Navigation", ["Apprentissage", "Tester"])

# Store the best model in session_state
if "model_data" not in st.session_state:
    st.session_state.model_data = {"model": None, "classes": []}

if page == "Apprentissage":
    st.header("📦 Upload du Dataset")
    zip_file = st.file_uploader("Uploader un fichier .zip contenant TRAIN/ et VAL/", type=["zip"])

    if zip_file:
        with st.spinner("Décompression..."):
            base_dir = extract_zip(zip_file)
            train_path = os.path.join(base_dir,"data" ,"TRAIN")
            val_path = os.path.join(base_dir,"data", "VAL")

        st.success("Dossier extrait. Choisissez un modèle pour entraîner.")

        cols = st.columns(3)
        accs = {}

        for i, model_name in enumerate(["Facebook", "Google", "Microsoft"]):
            if cols[i].button(f"Apprendre avec {model_name}"):
                with st.spinner(f"Entraînement du modèle {model_name}..."):
                    model, acc, classes = train_model(model_name, train_path, val_path)
                    accs[model_name] = acc
                    st.success(f"{model_name} - Précision validation : {acc:.2f}")

                    if st.session_state.model_data["model"] is None or acc > st.session_state.model_data["model"][1]:
                        st.session_state.model_data["model"] = (model, acc)
                        st.session_state.model_data["classes"] = classes
                        st.info(f"✅ {model_name} sélectionné comme meilleur modèle")

elif page == "Tester":
    st.header("🔍 Tester une image")

    if st.session_state.model_data["model"] is None:
        st.warning("Veuillez d'abord entraîner un modèle dans l'onglet 'Apprentissage'")
    else:
        uploaded_img = st.file_uploader("Uploader une image à classer", type=["jpg", "png", "jpeg"])
        if uploaded_img:
            image = Image.open(uploaded_img).convert("RGB")
            st.image(image, caption="Image à classer", use_column_width=True)

            if st.button("Classifier l’image"):
                img = image.resize((224, 224))
                img_array = np.expand_dims(np.array(img) / 255.0, axis=0)

                model = st.session_state.model_data["model"][0]
                class_names = st.session_state.model_data["classes"]
                pred = np.argmax(model.predict(img_array), axis=1)[0]
                st.success(f"🧾 Classe prédite : **{class_names[pred]}**")